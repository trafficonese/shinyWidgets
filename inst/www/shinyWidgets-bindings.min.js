// airDatepicker bindings //
// by Vic //

var AirPickerInputBinding = new Shiny.InputBinding();
$.extend(AirPickerInputBinding, {
  initialize: function initialize(el) {
    var config = $(el)
      .parent()
      .parent()
      .find('script[data-for="' + el.id + '"]');

    config = JSON.parse(config.html());
    var options = config.options;

    if (config.hasOwnProperty("value")) {
      var dateraw = config.value;
      var datedefault = [];
      for (var i = 0; i < dateraw.length; i++) {
        datedefault[i] = new Date(dateraw[i]);
      }
      config.value = datedefault;
    }

    if (options.hasOwnProperty("minDate")) {
      options.minDate = new Date(options.minDate);
    }
    if (options.hasOwnProperty("maxDate")) {
      options.maxDate = new Date(options.maxDate);
    }
    if (options.hasOwnProperty("startDate")) {
      options.startDate = new Date(options.startDate);
    }
    if (config.todayButtonAsDate) {
      options.todayButton = new Date(options.todayButton);
    }

    // disable dates
    if (config.hasOwnProperty("disabledDates")) {
      var disabledDates = config.disabledDates;
      options.onRenderCell = function(d, type) {
        if (type == "day") {
          var disabled = false,
            formatted = getFormattedDate(d);

          disabled = disabledDates.filter(function(date) {
            return date == formatted;
          }).length;

          return {
            disabled: disabled
          };
        }
      };
    }

    if (config.updateOn == "close") {
      options.onHide = function(inst, animationCompleted) {
        if (animationCompleted) {
          $(el).trigger("change");
        }
      };
    } else {
      options.onSelect = function(formattedDate, date, inst) {
        $(el).trigger("change");
      };
    }

    var dp = $(el)
          .datepicker(options)
          .data("datepicker");
    dp.selectDate(config.value);
    if (config.hasOwnProperty("startView")) {
      dp.date = new Date(config.startView);
    }
  },
  find: function(scope) {
    return $(scope).find(".sw-air-picker");
  },
  getId: function(el) {
    return $(el).attr("id");
  },
  getType: function(el) {
    // console.log($(el).attr('data-timepicker') === 'false');
    if ($(el).attr("data-timepicker") !== "false") {
      return "air.datetime";
    } else {
      return "air.date";
    }
  },
  getValue: function(el) {
    //return el.value;

    var sd = $(el)
      .datepicker()
      .data("datepicker").selectedDates;
    var timepicker = $(el).attr("data-timepicker");
    var res;

    function padZeros(n, digits) {
      var str = n.toString();
      while (str.length < digits) {
        str = "0" + str;
      }
      return str;
    }
    function formatDate(date) {
      if (date instanceof Date) {
        return (
          date.getFullYear() +
          "-" +
          padZeros(date.getMonth() + 1, 2) +
          "-" +
          padZeros(date.getDate(), 2)
        );
      } else {
        return null;
      }
    }

    if (sd.length > 0) {
      if (timepicker === "false") {
        res = sd.map(function(e) {
          //console.log(e);
          return formatDate(e);
        });
      } else {
        //var tz = new Date().toString().match(/([-\+][0-9]+)\s/)[1];
        res = sd.map(function(e) {
          return e.valueOf(); //toISOString() + tz;
        });
        //res = sd ;
      }
      return res;
    } else {
      return null;
    }
  },
  setValue: function(el, value) {
    value = JSON.parse(value);
    var newdate = [];
    for (var i = 0; i < value.length; i++) {
      newdate[i] = new Date(value[i]);
    }
    var datepicker = $(el)
      .datepicker()
      .data("datepicker");
    datepicker.selectDate(newdate);
    //datepicker.date = newdate[0];
  },
  subscribe: function(el, callback) {
    $(el).on("change", function(event) {
      callback();
    });
  },
  unsubscribe: function(el) {
    $(el).off(".AirPickerInputBinding");
  },
  receiveMessage: function(el, data) {
    if (data.clear) {
      $(el)
        .datepicker()
        .data("datepicker")
        .clear();
    }
    if (data.hasOwnProperty("value")) this.setValue(el, data.value);

    if (data.hasOwnProperty("label")) {
      // console.log(el);
      $(el)
        .parent()
        .parent()
        .find('label[for="' + data.id + '"]')
        .text(data.label);
    }

    if (data.hasOwnProperty("options")) {
      if (data.options.hasOwnProperty("minDate")) {
        data.options.minDate = new Date(data.options.minDate);
      }
      if (data.options.hasOwnProperty("maxDate")) {
        data.options.maxDate = new Date(data.options.maxDate);
      }
      $(el)
        .datepicker()
        .data("datepicker")
        .update(data.options);
    }

    if (data.hasOwnProperty("placeholder")) {
      $("#" + data.id)[0].placeholder = data.placeholder;
    }

    $(el).trigger("change");
  }
});
Shiny.inputBindings.register(AirPickerInputBinding, "shiny.AirPickerInput");

/*
function parse_date(date) {
  return date.getUTCFullYear() + '-' + date.getUTCMonth() + '-' + date.getUTCDate();
}
*/

Date.prototype.yyyymmdd = function() {
  var mm = this.getMonth() + 1; // getMonth() is zero-based
  var dd = this.getDate();

  return [
    this.getFullYear(),
    (mm > 9 ? "" : "0") + mm,
    (dd > 9 ? "" : "0") + dd
  ].join("-");
};

function getFormattedDate(date) {
  var year = date.getFullYear(),
    month = date.getMonth() + 1,
    day = date.getDate();

  if (month > 9) {
    if (day > 9) {
      return year + "-" + month + "-" + day;
    } else {
      return year + "-" + month + "-0" + day;
    }
  } else {
    if (day > 9) {
      return year + "-0" + month + "-" + day;
    } else {
      return year + "-0" + month + "-0" + day;
    }
  }
}


// Transform each tag with class 'sw-switchInput' to bootstrap switch
$(function() {
  $('.sw-switchInput').each(function() {
    $(this).bootstrapSwitch();
  });
});

// switch input binding
var switchInputBinding = new Shiny.InputBinding();
$.extend(switchInputBinding, {
  find: function(scope) {
    return $(scope).find('.sw-switchInput');
  },
  getId: function(el) {
    return el.id;
  },
  getValue: function(el) {
    return el.checked;
  },
  setValue: function(el, value) {
    el.checked = value;
  },
  subscribe: function(el, callback) {
    $(el).on('switchChange.bootstrapSwitch', function(event) {
      callback(false);
    });
  },
  unsubscribe: function(el) {
    $(el).off('.switchInputBinding');
  },
  getState: function(el) {
    return {
      //label: $(el).parent().find('span').text(),
      value: el.checked
    };
  },
  receiveMessage: function(el, data) {

    if (data.hasOwnProperty('value'))
      el.checked = data.value;

    if (data.hasOwnProperty('label'))
      $(el).bootstrapSwitch('labelText', data.label);

    if (data.hasOwnProperty('offLabel'))
      $(el).bootstrapSwitch('offText', data.offLabel);

    if (data.hasOwnProperty('onLabel'))
      $(el).bootstrapSwitch('onText', data.onLabel);

    if (data.hasOwnProperty('onStatus'))
      $(el).bootstrapSwitch('onColor', data.onStatus);

    if (data.hasOwnProperty('offStatus'))
      $(el).bootstrapSwitch('offColor', data.offStatus);

    if (data.hasOwnProperty('disabled'))
      $(el).bootstrapSwitch('disabled', data.disabled, data.disabled);

    $(el).trigger('change');
   },
    initialize: function initialize(el) {
      $(el).bootstrapSwitch();
    }
});

Shiny.inputBindings.register(switchInputBinding, 'shiny.switchInput');


// ------------------------------------------------------------------------ //
//
// Descriptif : Checkbox Group Buttons : javascript bindings
//     Detail : http://getbootstrap.com/javascript/#buttons-checkbox-radio
//
//
// Auteur : Victor PERRIER
//
// Date creation : 01/07/2016
// Date modification : 01/07/2016
//
// Version 1.0
//
// ------------------------------------------------------------------------ //



// Prevent focus on button after click
document.addEventListener('click', function(e) {

  if(document.activeElement.toString() == '[object HTMLButtonElement]' & document.activeElement.classList.contains('checkbtn')) {
    document.activeElement.blur();
  }

});


var exports4but = window.Shiny = window.Shiny || {};
var $escape4but = exports4but.$escape = function(val) {
  return val.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, '\\$1');
};

// checkboxGroupButtons input binding
var checkboxGroupButtonsBinding = new Shiny.InputBinding();
$.extend(checkboxGroupButtonsBinding, {
  find: function(scope) {
    return $(scope).find('.checkboxGroupButtons');
  },
  getId: function(el) {
    return el.id;
  },
  getValue: function(el) {
    // Select the checkbox objects that have name equal to the grouping div's id
    var $objs = $('input:checkbox[name="' + $escape4but(el.id) + '"]:checked');
    var values = new Array($objs.length);
    for (var i = 0; i < $objs.length; i++) {
      values[i] = $objs[i].value;
    }
    return values;
  },
  setValue: function(el, value) {
    $('input:checkbox[name="' + $escape4but(el.id) + '"]').prop('checked', false);
    $('input:checkbox[name="' + $escape4but(el.id) + '"]').parent().removeClass('active');
    $('input:checkbox[name="' + $escape4but(el.id) + '"]').parent().blur();
    // Accept array
      if (value instanceof Array) {
        for (var i = 0; i < value.length; i++) {
          $('input:checkbox[name="' + $escape4but(el.id) + '"][value="' + $escape4but(value[i]) + '"]').parent().addClass('active');
          $('input:checkbox[name="' + $escape4but(el.id) + '"][value="' + $escape4but(value[i]) + '"]').prop('checked', true);
        }
        // Else assume it's a single value
      } else {
          $('input:checkbox[name="' + $escape4but(el.id) + '"][value="' + $escape4but(value) + '"]').parent().addClass('active');
          $('input:checkbox[name="' + $escape4but(el.id) + '"][value="' + $escape4but(value) + '"]').prop('checked', true);
    }
  },
  subscribe: function(el, callback) {
    $(el).on('change.checkboxGroupButtonsBinding', function (event) {
        callback();
    });
  },
  unsubscribe: function(el) {
    $(el).off('.checkboxGroupButtonsBinding');
  },
  getState: function getState(el) {
      var $objs = $('input:checkbox[name="' + $escape4but(el.id) + '"]');

      // Store options in an array of objects, each with with value and label
      var options = new Array($objs.length);
      for (var i = 0; i < options.length; i++) {
        options[i] = { value: $objs[i].value };
      }

      return { value: this.getValue(el), options: options };
  },
  receiveMessage: function receiveMessage(el, data) {
      var $el = $(el);

      // This will replace all the options
      if (data.hasOwnProperty('options')) {
        $el.find('div.btn-group-container-sw').empty();
        $el.find('div.btn-group-container-sw').append(data.options);
      }

      if (data.hasOwnProperty('selected'))
        this.setValue(el, data.selected);

      if (data.hasOwnProperty('label'))
        $el.find('label[for="' + $escape4but(el.id) + '"]').text(data.label);

      $(el).trigger('change');
  }
});

Shiny.inputBindings.register(checkboxGroupButtonsBinding, 'shiny.checkboxGroupButtonsInput');

var exportsKnob = window.Shiny = window.Shiny || {};
var $escapeKnob = exportsKnob.$escape = function(val) {
    return val.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, '\\$1');
};



function tron_skin() {

    // "tron" case
    if (this.$.data('skin') == 'tron') {
        this.cursorExt = 0.3;
        var a = this.arc(this.cv), // Arc
            pa, // Previous arc
            r = 1;
        this.g.lineWidth = this.lineWidth;
        if (this.o.displayPrevious) {
            pa = this.arc(this.v);
            this.g.beginPath();
            this.g.strokeStyle = this.pColor;
            this.g.arc(this.xy, this.xy, this.radius - this.lineWidth, pa.s, pa.e, pa.d);
            this.g.stroke();
        }
        this.g.beginPath();
        this.g.strokeStyle = r ? this.o.fgColor : this.fgColor;
        this.g.arc(this.xy, this.xy, this.radius - this.lineWidth, a.s, a.e, a.d);
        this.g.stroke();
        this.g.lineWidth = 2;
        this.g.beginPath();
        this.g.strokeStyle = this.o.fgColor;
        this.g.arc(this.xy, this.xy, this.radius - this.lineWidth + 1 + this.lineWidth * 2 / 3, 0, 2 * Math.PI, false);
        this.g.stroke();
        return false;
    }
}




// Knob input binding

var knobInputBinding = new Shiny.InputBinding();


// An input binding must implement these methods
$.extend(knobInputBinding, {

    // This returns a jQuery object with the DOM element
    find: function(scope) {
        return $(scope).find('.knob-input');
    },

    // this method will be called on initialisation
    initialize: function(el) {

        // extract the value from el
        // note here our knobInput does not yet exist
        var value = $(el).data("value");

        // initialize our knob based on the extracted state
        el.value = value;

        // Initialize knob
        $(el).knob({draw: tron_skin});
    },

    // Given the DOM element for the input, return the value
    getValue: function(el) {
        return parseFloat(el.value);
    },

    // Set up the event listeners so that interactions with the
    // input will result in data being sent to server.
    // callback is a function that queues data to be sent to
    // the server.
    subscribe: function(el, callback) {
      var immediate = $(el).data("immediate");
      if (immediate) {
        $(el).on('keyup.knobInputBinding', function(event) {
            callback(true);
            // When called with true, it will use the rate policy,
            // which in this case is to debounce at 500ms.
        });

        $(el).trigger('configure', {
            'change': function(v) {
                callback(false);
            },
            'release' : function (v) {
                callback(false);
            }
        });

        $(el).on('change.knobInputBinding', function(event) {
            callback(false);
            // When called with false, it will NOT use the rate policy,
            // so changes will be sent immediately
        });
      } else {
        $(el).on('keyup.knobInputBinding', function(event) {
            callback(true);
            // When called with true, it will use the rate policy,
            // which in this case is to debounce at 500ms.
        });
        $(el).trigger('configure', {
            'release' : function (v) {
                callback(true);
            }
        });
      }

    },

    // Remove the event listeners
    unsubscribe: function(el) {
        $(el).off('.knobInputBinding');
    },

    // Receive messages from the server.
    // Messages sent by updateknobInput() are received by this function.
    receiveMessage: function(el, data) {
        if (data.hasOwnProperty('value')) {
            $(el)
                .val(data.value)
                .trigger('change');
        }

        if (data.hasOwnProperty('readOnly')) {
            $(el).trigger(
                'configure', {
                    "readOnly": data.readOnly
                }
            );
        }

        if (data.hasOwnProperty('options')) {
          $(el).trigger('configure', data.options);
        }


        if (data.hasOwnProperty('label'))
            $(el).parent().parent().find('label[for="' + $escapeKnob(el.id) + '"]').text(data.label);

        $(el).trigger('change');
    },

    // This returns a full description of the input's state.
    // Note that some inputs may be too complex for a full description of the
    // state to be feasible.
    getState: function(el) {
        return {
            label: $(el).parent().parent().find('label[for="' + $escapeKnob(el.id) + '"]').text(),
            value: el.value
        };
    },

    // The input rate limiting policy
    getRatePolicy: function() {
        return {
            // Can be 'debounce' or 'throttle'
            policy: 'debounce',
            delay: 500
        };
    }

});

Shiny.inputBindings.register(knobInputBinding, 'shiny.knobInput');


// multi input binding
var exportsMulti = window.Shiny = window.Shiny || {};
var $escapeMulti = exportsMulti.$escape = function(val) {
  return val.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, '\\$1');
};

var multiInputBinding = new Shiny.InputBinding();
  $.extend(multiInputBinding, {
    initialize: function initialize(el) {
      var config = $(el).parent().find('script[data-for="' + $escapeMulti(el.id) + '"]');
      config = JSON.parse(config.html());
      $(el).multi(config);
      $(el).trigger('change');
    },
    find: function(scope) {
      return $(scope).find('.multijs');
    },
    getId: function(el) {
      return el.id;
    },
    getValue: function(el) {
      return $(el).val();
    },
    setValue: function setValue(el, value) {
      $(el).val(value);
      $(el).multi();
      $(el).trigger('change');
    },
    getState: function(el) {
      // Store options in an array of objects, each with with value and label
      var options = new Array(el.length);
      for (var i = 0; i < el.length; i++) {
        options[i] = { value: el[i].value,
          label: el[i].label };
      }

      return {
        label: $(el).parent().find('label[for="' + $escapeMulti(el.id) + '"]').text(),
        value: this.getValue(el),
        options: options
      };
    },
    receiveMessage: function(el, data) {
      var $el = $(el);

      // This will replace all the options
      if (data.hasOwnProperty('options')) {
        // Clear existing options and add each new one
        $el.empty().append(data.options);
        //$(el).trigger( 'change' );
      }

      if (data.hasOwnProperty('value')) {
        this.setValue(el, data.value);
      }

      if (data.hasOwnProperty('label')) $(el).parent().parent().find('label[for="' + $escapeMulti(el.id) + '"]').text(data.label);

      var event = new Event('change');

      //$(el.id).trigger( 'change' );
      $(el).multi();
      $el.get(0).dispatchEvent(event);
      $el.trigger('change');

      // $(el).siblings(".multi-wrapper").find(".search-input").get(0).dispatchEvent(event); //
    },
    subscribe: function(el, callback) {
      $(el).on('change', function (event) {
        callback();
      });
    },
    unsubscribe: function(el) {
      $(el).off('.multiInputBinding');
    }
});
Shiny.inputBindings.register(multiInputBinding, 'shiny.multiInput');
// noUiSlider bindings by VP //

var exportsnoUi = window.Shiny = window.Shiny || {};
var $escapenoUi = exportsnoUi.$escape = function(val) {
  return val.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, '\\$1');
};


var noUiSliderBinding = new Shiny.InputBinding();
  $.extend(noUiSliderBinding, {
  find: function find(scope) {
      return $(scope).find('.sw-no-ui-slider');
  },
  getId: function getId(el) {
      return el.id;
  },
    getType: function getType(el) {
      var dataType = $(el).data('data-type');
      if (dataType === 'date') return 'shiny.date';else if (dataType === 'datetime') return 'shiny.datetime';else return false;
    },
    getValue: function getValue(el) {
      var slider = document.getElementById(el.id);
      var values = slider.noUiSlider.get();
      var result;

      var $el = $(el);
      var config = $el.parent().find('script[data-for="' + $escapenoUi(el.id) + '"]');
      config = JSON.parse(config.html());
      if (typeof config.format !== 'undefined') {
        numformat = wNumb(config.format);
        if (Array.isArray(values)) {
          result = values.map(numformat.from);
        } else {
          result = numformat.from(values);
        }
      } else {
        if (Array.isArray(values)) {
          result = values.map(Number);
        } else {
          result = Number(values);
        }
      }
      //var result = values.map(Number);
      return result;
    },
    setValue: function setValue(el, value) {
      var slider = document.getElementById(el.id);
      slider.noUiSlider.set(value);
    },
    subscribe: function subscribe(el, callback) {
      var slider = document.getElementById(el.id);
      var update_on = $( '#' + el.id ).data( "update" );
      if (update_on == "end") {
        slider.noUiSlider.on('change', function (event) {
          callback();
        });
        slider.noUiSlider.on('set', function (event) {
          callback();
        });
      } else {
        slider.noUiSlider.on('slide', function (event) {
          callback();
        });
        slider.noUiSlider.on('set', function (event) {
          callback();
        });
      }
    },
    unsubscribe: function unsubscribe(el) {
      $(el).off('.noUiSliderBinding');
    },
    receiveMessage: function receiveMessage(el, data) {
      var slider = document.getElementById(el.id);
      if (data.disable) {
        slider.setAttribute('disabled', true);
      } else {
        slider.removeAttribute('disabled');
      }
      if (data.hasOwnProperty('range')) {
        slider.noUiSlider.updateOptions({
      		range: {
      			'min': data.range[0],
      			'max': data.range[1]
      		}
      	});
      }
      slider.noUiSlider.set(data.value);
      $(el).trigger('change');
    },
    getRatePolicy: function getRatePolicy() {
      return {
        policy: 'debounce',
        delay: 250
      };
    },
    getState: function getState(el) {},
    initialize: function initialize(el) {
      var $el = $(el);
      var config = $el.parent().find('script[data-for="' + $escapenoUi(el.id) + '"]');
      config = JSON.parse(config.html());
      if (typeof config.format !== 'undefined') {
        config.format = wNumb(config.format);
      }
      var slider = document.getElementById(el.id);
      if (config.orientation === 'vertical') {
        slider.style.margin = '0 auto 30px';
      }
      noUiSlider.create(slider, config);
    }
  });

Shiny.inputBindings.register(noUiSliderBinding, "shiny.noUiSlider");
var numericRangeInputBinding = new Shiny.InputBinding();
$.extend(numericRangeInputBinding, {
  find: function(scope) {
    return $(scope).find('.shiny-numeric-range-input');
  },
  getValue: function(el) {

    var $inputs = $(el).find('input');
    var start = $inputs[0].value;
    var end   = $inputs[1].value;


    if (/^\s*$/.test(start))  // Return null if all whitespace
      start = null;
    else if (!isNaN(start))   // If valid Javascript number string, coerce to number
      start = +start;
    else
      start = start;

    if (/^\s*$/.test(end))  // Return null if all whitespace
      end = null;
    else if (!isNaN(end))   // If valid Javascript number string, coerce to number
      end = +end;
    else
      end = end;

    return [start, end];
  },
  setValue: function(el, value) {
    el.find('input')[0].value = value[0];
    el.find('input')[1].value = value[1];
  },
  subscribe: function(el, callback) {
    $(el).on("change.numericRangeInputBinding", function(e) {
      callback();
    });
  },
  receiveMessage: function(el, data) {
      var $el = $(el);

      //if (data.hasOwnProperty('label')) $el.find('label[for="' + $escape(el.id) + '"]').text(data.label);

      if (data.hasOwnProperty('value'))
        $el.find('input')[0].value = data.value[0];
        $el.find('input')[1].value = data.value[1];

      $(el).trigger('change');
    },
  unsubscribe: function(el) {
    $(el).off(".numericRangeInputBinding");
  }
});

Shiny.inputBindings.register(numericRangeInputBinding,"wd.numericRangeInputBin");


// ProgressBars bindings
Shiny.addCustomMessageHandler('update-progressBar-shinyWidgets', function(data) {
  var id = data.id;
  var total = data.total;
  var value = Math.round(data.value);
  //console.log(data.statusp);
  //var statusp = typeof data.statusp !== 'undefined' ? data.statusp : "none";
  var pct;
  if (total > 0) {
    pct = Math.round(value / total * 100);
    $('#' + id + '-value').text(value);
    $('#' + id + '-total').text(total);
    value = Math.round(value / total * 100);
  } else {
    pct = data.percent > 0 ? data.percent : value;
  }
  $('#' + id).css('width', pct + '%');
  var txt = $('#' + id).text();
  if (txt !== "") { //value.display_pct !== undefined
    $('#' + id).text(value + data.unit_mark);
  }
  if (data.status !== null) {
    $('#' + id).removeClass();
    $('#' + id).addClass("progress-bar progress-bar-" + data.status);
  }
  if (data.title !== null) {
    $('#' + id + '-title').text(data.title);
  }
});




// ------------------------------------------------------------------------ //
//
// Descriptif : Radio Group Buttons : javascript bindings
//     Detail : http://getbootstrap.com/javascript/#buttons-checkbox-radio
//
//
// Auteur : Victor PERRIER
//
// Date creation : 01/07/2016
// Date modification : 01/07/2016
//
// Version 1.0
//
// ------------------------------------------------------------------------ //




var exports4but = window.Shiny = window.Shiny || {};
var $escape4but = exports4but.$escape = function(val) {
  return val.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, '\\$1');
};

// radioGroupButtons input binding
var radioGroupButtonsBinding = new Shiny.InputBinding();
$.extend(radioGroupButtonsBinding, {
  find: function(scope) {
    return $(scope).find('.radioGroupButtons');
  },
  getId: function(el) {
    return el.id;
  },
  getValue: function(el) {
    return $('input:radio[name="' + $escape4but(el.id) + '"]:checked').val();
  },
  setValue: function(el, value) {
    $('input:radio[name="' + $escape4but(el.id) + '"][value="' + $escape4but(value) + '"]').prop('checked', true);
    $('input:radio[name="' + $escape4but(el.id) + '"]').parent().removeClass('active');
    $('input:radio[name="' + $escape4but(el.id) + '"][value="' + $escape4but(value) + '"]').parent().addClass('active');
  },
  subscribe: function(el, callback) {
    $(el).on('change.radioGroupButtonsBinding', function (event) {
        callback();
    });
  },
  unsubscribe: function(el) {
    $(el).off('.radioGroupButtonsBinding');
  },
  getState: function getState(el) {
      var $objs = $('input:radio[name="' + $escape4but(el.id) + '"]');

      // Store options in an array of objects, each with with value and label
      var options = new Array($objs.length);
      for (var i = 0; i < options.length; i++) {
        options[i] = { value: $objs[i].value,
        label: this._getLabel($objs[i]) };
      }

      return {
        label: $(el).parent().find('label[for="' + $escape4but(el.id) + '"]').text(),
        value: this.getValue(el),
        options: options
    };
  },
  receiveMessage: function receiveMessage(el, data) {
      var $el = $(el);

      // This will replace all the options
      if (data.hasOwnProperty('options')) {
        $el.find('div.btn-group-container-sw').empty();
        $el.find('div.btn-group-container-sw').append(data.options);
      }

      if (data.hasOwnProperty('selected'))
        this.setValue(el, data.selected);

      if (data.hasOwnProperty('label'))
        $(el).parent().find('label[for="' + $escape4but(el.id) + '"]').text(data.label);

      $(el).trigger('change');
  }
});

Shiny.inputBindings.register(radioGroupButtonsBinding, 'shiny.radioGroupButtonsInput');


// searchInput bindings //
// by VP 4 dreamRs //


var exportsSearch = window.Shiny = window.Shiny || {};
var $escapeSearch = exportsSearch.$escape = function(val) {
  return val.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, '\\$1');
};

var searchInputBinding = new Shiny.InputBinding();
$.extend(searchInputBinding, {
  find: function(scope) {
  	return $(scope).find('.search-text');
  },
  getId: function(el) {
  	//return InputBinding.prototype.getId.call(this, el) || el.name;
  	return $(el).attr('id');
  },
  getValue: function(el) {
  	//return el.value;
  	return $('#' + $escapeSearch(el.id) + '_text').val();
  },
  setValue: function(el, value) {
  	$('#' + $escapeSearch(el.id) + '_text').val(value);
  },
  subscribe: function(el, callback) {
   $('#' + $escapeSearch(el.id) + '_text').on('keyup.searchInputBinding input.searchInputBinding', function(event) {
     if(event.keyCode == 13) { //if enter
  	  callback();
     }
   });
   $('#' + $escapeSearch(el.id) + '_search').on('click', function(event) { // on click
      callback();
   });
   $('#' + $escapeSearch(el.id) + '_reset').on('click', function(event) { // on click
      var reset = $('#' + $escapeSearch(el.id)).data('reset');
      if (reset == 'TRUE') {
        var resetValue = $('#' + $escapeSearch(el.id)).data('reset-value');
        $('#' + $escapeSearch(el.id) + '_text').val(resetValue);
      }
      callback();
   });
  },
  unsubscribe: function(el) {
  	$(el).off('.searchInputBinding');
  },
  receiveMessage: function(el, data) {
  	if (data.hasOwnProperty('value')) this.setValue(el, data.value);

    if (data.hasOwnProperty('label')) {
      // console.log(el);
      $(el).parent().find('label[for="' + el.id + '"]').text(data.label);
    }

    if (data.hasOwnProperty('placeholder')) {
      $('#' + el.id + '_text')[0].placeholder = data.placeholder;
    }

    if (data.trigger) {
      $('#' + el.id + '_search').click();
    }

    $(el).trigger('change');
  },
  getState: function(el) {
  	return {
    	//label: $(el).parent().find('label[for=' + el.id + ']').text(),
    	value: this.getValue(el)//el.value
  	};
  },
  getRatePolicy: function() {
  	return {
  	policy: 'debounce',
  	delay: 250
  	};
  }
});
Shiny.inputBindings.register(searchInputBinding, 'shiny.searchInput');

// picker input binding
var exportsPicker = window.Shiny = window.Shiny || {};
var $escapePicker = exportsPicker.$escape = function(val) {
  return val.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, '\\$1');
};

var pickerInputBinding = new Shiny.InputBinding();
  $.extend(pickerInputBinding, {
    find: function find(scope) {
      return $(scope).find('.selectpicker');
    },
    getId: function getId(el) {
      return el.id;
    },
    getValue: function getValue(el) {
      return $(el).val();
    },
    setValue: function setValue(el, value) {
      $(el).val(value);
      $(el.id).selectpicker('refresh');
    },
    getState: function getState(el) {
      // Store options in an array of objects, each with with value and label
      var options = new Array(el.length);
      for (var i = 0; i < el.length; i++) {
        options[i] = { value: el[i].value,
          label: el[i].label };
      }

      return {
        label: $(el).parent().find('label[for="' + $escapePicker(el.id) + '"]').text(),
        value: this.getValue(el),
        options: options
      };
    },
    receiveMessage: function receiveMessage(el, data) {
      var $el = $(el);

      if (data.hasOwnProperty('options')) {
        //this.picker.selectpicker('destroy');
        $(el).attr(data.options);
        this.picker.selectpicker('render');
      }

      // This will replace all the choices
      if (data.hasOwnProperty('choices')) {
        // Clear existing choices and add each new one
        $el.empty().append(data.choices);
        $(el).selectpicker('refresh');
      }

      if (data.hasOwnProperty('value')) {
        this.setValue(el, data.value);
      }

      if (data.hasOwnProperty('label')) $(el).parent().parent().find('label[for="' + $escapePicker(el.id) + '"]').text(data.label);

      //$(el).selectpicker('refresh');
      $(el).trigger('change');
    },
    subscribe: function subscribe(el, callback) {
      $(el).on('changed.bs.select', function (event) {
        //$(el).selectpicker('refresh');
        console.log("changed.bs.select");
        callback();
      });
      $(el).on('hidden.bs.select', function (event) {
        console.log("hidden.bs.select");
        debugger;
      });
    },
    unsubscribe: function unsubscribe(el) {
      $(el).off('.pickerInputBinding');
    },
    initialize: function initialize(el) {
      this.picker = $(el).selectpicker();
    }
});
Shiny.inputBindings.register(pickerInputBinding, 'shiny.pickerInput');

function forceIonSliderTextUpdate(slider) {
  if (slider.$cache && slider.$cache.input) slider.$cache.input.trigger('change');else console.log("Couldn't force ion slider to update");
}
var exportsST = window.Shiny = window.Shiny || {};
var $escapeST = exportsST.$escape = function(val) {
  return val.replace(/([!"#$%&'()*+,.\/:;<=>?@\[\\\]^`{|}~])/g, '\\$1');
};
var sliderTextBinding = new Shiny.InputBinding();
  $.extend(sliderTextBinding, {
  find: function find(scope) {
      // Check if ionRangeSlider plugin is loaded
      if (!$.fn.ionRangeSlider) return [];

      return $(scope).find('.sw-slider-text');
    },
    getType: function getType(el) {
      var dataType = $(el).data('data-type');
      if (dataType === 'date') return 'shiny.date';else if (dataType === 'datetime') return 'shiny.datetime';else return false;
    },
    getValue: function getValue(el) {
      var slider = $(el).data('ionRangeSlider');
      var result = slider.result;
      var options = slider.options;

      ////var values = $(el).data("values").split(",");
      //var values = $(el).data("swvalues");
      var values = options.values;

      if (this._numValues(el) === 2) {
        return [values[result.from], values[result.to]];
      } else {
        return values[result.from];
      }
    },
    setValue: function setValue(el, value) {
      var $el = $(el);
      var slider = $el.data('ionRangeSlider');

      $el.data('immediate', true);
      try {
        if (this._numValues(el) === 2 && value instanceof Array) {
          slider.update({ from: value[0], to: value[1] });
        } else {
          slider.update({ from: value });
        }

        forceIonSliderTextUpdate(slider);
      } finally {
        $el.data('immediate', false);
      }
    },
    subscribe: function subscribe(el, callback) {
      $(el).on('change.sliderInputBinding', function (event) {
        callback(!$(el).data('immediate') && !$(el).data('animating'));
      });
    },
    unsubscribe: function unsubscribe(el) {
      $(el).off('.sliderInputBinding');
    },
    receiveMessage: function receiveMessage(el, data) {
      var $el = $(el);
      var slider = $el.data('ionRangeSlider');
      var options = slider.options;
      var msg = {};

      ////var values = $(el).data("values").split(",");
      //var values = $(el).data("swvalues");
      var values = options.values;

      if (data.hasOwnProperty('choices')) {
        msg.values = data.choices;
        values = data.choices;
      }

      if (data.hasOwnProperty('selected')) {
        if (this._numValues(el) === 2 && data.selected instanceof Array) {
          msg.from = values.indexOf(data.selected[0]);
          msg.to = values.indexOf(data.selected[1]);
        } else {
          msg.from = values.indexOf(data.selected);
        }
      }

      if (data.hasOwnProperty('from_fixed')) msg.from_fixed = data.from_fixed;
      if (data.hasOwnProperty('to_fixed')) msg.to_fixed = data.to_fixed;

      if (data.hasOwnProperty('label')) $el.parent().find('label[for="' + $escapeST(el.id) + '"]').text(data.label);

      $el.data('immediate', true);
      try {
        slider.update(msg);
        forceIonSliderTextUpdate(slider);
      } finally {
        $el.data('immediate', false);
      }
    },
    getRatePolicy: function getRatePolicy() {
      return {
        policy: 'debounce',
        delay: 250
      };
    },
    getState: function getState(el) {},
    initialize: function initialize(el) {
      var opts = {};
      var $el = $(el);

      var values = $(el).data("swvalues");
      //console.log(values);
      opts.values = values;

      $el.ionRangeSlider(opts);
    },

    // Number of values; 1 for single slider, 2 for range slider
    _numValues: function _numValues(el) {
      if ($(el).data('ionRangeSlider').options.type === 'double') return 2;else return 1;
    }
});

Shiny.inputBindings.register(sliderTextBinding, "shiny.sliderText");


// spectrumInput bindings //
// by VP 4 dreamRs //



var spectrumInputBinding = new Shiny.InputBinding();
$.extend(spectrumInputBinding, {
  find: function(scope) {
  	return $(scope).find('.sw-spectrum');
  },
  getId: function(el) {
  	return $(el).attr('id');
  },
  getValue: function(el) {
  	//return el.value;
  	return $(el).spectrum("get").toHexString();
  },
  setValue: function(el, value) {
  	$(el).spectrum("set", value);
  },
  subscribe: function(el, callback) {
   //$(el).on('move.spectrum dragstop.spectrum', function(event) {
   //  callback();
   //});
   $(el).on('change', function(event) {
     callback();
   });
  },
  unsubscribe: function(el) {
  	$(el).off('.spectrumInputBinding');
  },
  receiveMessage: function(el, data) {
  	if (data.hasOwnProperty('value'))
  	this.setValue(el, data.value);

  	//if (data.hasOwnProperty('label'))
  	//$(el).parent().find('label[for=' + el.id + ']').text(data.label);

  	$(el).trigger('change');
  },
  getState: function(el) {
  	return {
    	//label: $(el).parent().find('label[for=' + el.id + ']').text(),
    	value: this.getValue(el)//el.value
  	};
  },
  initialize: function initialize(el) {
    var opts = {};
    var update_on = $(el).attr('data-update-on');
    $(el).removeAttr('data-update-on');
    if (update_on == 'dragstop') {
      $(el).on('dragstop.spectrum', function(event) {
        $(el).trigger('change');
      });
    }
    if (update_on == 'move') {
      opts.move = function() {
        $(el).trigger('change');
      };
    }
    if (update_on == 'change') {
      opts.change = function() {
        $(el).trigger('change');
      };
    }
    $(el).spectrum(opts);
  },
  getRatePolicy: function getRatePolicy() {
    return {
      policy: 'debounce',
      delay: 250
    };
  }
});
Shiny.inputBindings.register(spectrumInputBinding, 'shiny.spectrumInput');

// Sweet-Alert Bindings

Shiny.addCustomMessageHandler('sweetalert-sw', function(data) {
  if (data.as_html) {
    var elsw = document.createElement("span");
    elsw.innerHTML = data.config.text;
    data.config.html = elsw;
    Swal.fire(data.config)
      .then(function(value){
        var els = $("#" + data.sw_id);
        els.each(function (i, el) {
          window.Shiny.unbindAll(el, true);
          $(el).remove();
          return true;
        });
      });
  } else {
    Swal.fire(data.config);
  }
});


Shiny.addCustomMessageHandler('sweetalert-sw-confirm', function(data) {
  Shiny.onInputChange(data.id, null);
  if (!data.as_html) {
    Swal.fire(data.swal).then(function(result) {
      if (result.value) {
        Shiny.onInputChange(data.id, true);
      } else {
        Shiny.onInputChange(data.id, false);
      }
    });
  } else {
    //var elsw = document.createElement("span");
    //elsw.innerHTML = data.swal.text;
    //data.swal.html = elsw;
    Swal.fire(data.swal)
      .then(function(result) {
        if (result.value) {
          Shiny.onInputChange(data.id, true);
        } else {
          Shiny.onInputChange(data.id, false);
        }
        var els = $("#" + data.sw_id);
        els.each(function (i, el) {
          window.Shiny.unbindAll(el, true);
          $(el).remove();
          return true;
        });
      });
  }
});


Shiny.addCustomMessageHandler('sweetalert-sw-input', function(data) {
  if (data.reset_input) {
    Shiny.setInputValue(data.id, null);
  }
  Swal.fire(data.swal).then(function(result) {
    Shiny.setInputValue(data.id, result.value, {priority: "event"});
  });
});


Shiny.addCustomMessageHandler('sweetalert-sw-progress', function(data) {
  var itm = document.getElementById(data.idel);
  itm.style.display = "block";
  data.content = itm;
  Swal.fire(data);
});


Shiny.addCustomMessageHandler('sweetalert-toast', function(data) {
  Swal.fire(data);
});


// https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
(function (arr) {
  arr.forEach(function (item) {
    if (item.hasOwnProperty('remove')) {
      return;
    }
    Object.defineProperty(item, 'remove', {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        if (this.parentNode === null) {
          return;
        }
        this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);


Shiny.addCustomMessageHandler('sweetalert-sw-close', function(data) {
  Swal.close();
});
// Vertical Tab Input binding

var shinyMode = typeof(window.Shiny) !== "undefined" && !!window.Shiny.inputBindings;

if (shinyMode) {
  var VerticalTabInputBinding = new Shiny.InputBinding();
    $.extend(VerticalTabInputBinding, {
      find: function(scope) {
        return $(scope).find('.vertical-tab-panel');
      },
      getId: function(el) {
        return el.id;
      },
      getValue: function(el) {
        return $(el).find(".active").attr("data-value");
      },
      setValue: function setValue(el, value) {

      },
      receiveMessage: function(el, data) {
        var $el = $(el);

        if (data.hasOwnProperty('value')) {
          $el.find("[data-value='" + data.value + "']").click();
        } else if (data.hasOwnProperty('validate')) {
          if($el.children(".active").length === 0 && $el.children().length > 0) {
            $el.children().last().click();
          }
        } else if (data.hasOwnProperty('reorder')) {
          var items = $el.children();
          items.detach();
          $el.append( $.map(data.reorder, function(v) { return items[v - 1]; }) );
        }

      },
      subscribe: function(el, callback) {
        $(el).on('click', function (event) {
          callback();
        });
      },
      unsubscribe: function(el) {
        $(el).off('.VerticalTabInputBinding');
      }
  });
  Shiny.inputBindings.register(VerticalTabInputBinding, 'shiny.VerticalTabInput');
}
